参数依赖查找（`Argument Dependent Lookup`, `ADL`）是C++中的一种名称查找规则，用于在函数调用时确定函数的候选集。`ADL`允许编译器在调用函数时，除了在函数声明的命名空间或作用域中查找之外，还可以在函数参数类型所在的命名空间中查找函数的定义。这意味着即使没有显式指定命名空间，编译器也能找到正确的函数。

当你调用一个函数时，如果该函数的名称没有在当前作用域中找到，编译器会尝试ADL来查找函数。ADL的查找范围包括：
- 函数参数类型所在的命名空间。
- 如果函数参数是类类型，则包括该类的基类所在的命名空间以及类成员的命名空间。

```cpp
namespace ns {
    struct MyType {};

    void func(MyType) {
        std::cout << "In ns::func" << std::endl;
    }
}

int main() {
    ns::MyType obj;
    func(obj); // 这里会使用ADL
    return 0;
}
```

需要注意的是：
1. `ADL`只适用于非成员函数的调用。
2. `ADL`可以和正常的命名空间查找一起工作，如果在当前作用域和通过`ADL`找到了同名的函数，那么这些函数都会被考虑进候选函数集。
3. `ADL`对模板函数特别有用，因为它允许模板函数在模板参数类型所在的命名空间中被找到和调用

# 匹配多个函数时的选择策略

当找到多个匹配的函数时，编译器将通过重载解析（`overload resolution`）规则来决定使用哪个函数。重载解析的过程考虑了各种因素，包括函数参数的类型匹配程度、是否有默认参数、函数模板的特化和实例化等，以确定最佳匹配。以下是决定过程的简化概述：

1. **精确匹配**：编译器首先查找参数类型完全匹配的函数。如果有多个函数参数类型完全一样，那么会产生一个编译错误，因为编译器无法决定使用哪个函数。

2. **提升和转换**：如果没有精确匹配，编译器会尝试通过标准转换（如整型提升、浮点数提升、整型和浮点数之间的转换等）来匹配函数。如果通过标准转换能找到匹配的函数，那么最少转换步骤的函数会被选中。

3. **用户定义的转换**：如果标准转换不能解决问题，编译器会考虑用户定义的类型转换。这包括类类型的转换运算符和单参数构造函数。同样，转换步骤最少的函数会被选中。

4. **模板函数特化**：如果涉及到模板函数，编译器会考虑模板参数推导和特化。最具体的（即最匹配的）模板特化会被选中。

5. **基于作用域的选择**：如果函数通过`ADL`和常规的作用域查找（例如，在函数调用点的命名空间或其父命名空间中）都找到了候选函数，那么这些函数都会被考虑在内。如果在这个过程中找到了多个同样适合的函数，那么会产生一个模糊性错误。

如果在所有这些步骤之后仍然有多个函数符合条件，那么编译器将报错，指出有多个重载函数匹配调用。

因此，没有一个固定的“优先级”来决定哪个函数会被选择，而是通过一系列复杂的规则来决定最合适的函数。在实践中，为了避免这种模糊性，最好尽量避免创建可能导致`ADL`产生多个匹配函数的情况。

---

```cpp
#include <iostream>

namespace ns {
    struct MyType {};

    void func(MyType) {
        std::cout << "In ns::func" << std::endl;
    }
}

void func(ns::MyType) {
    std::cout << "In global func" << std::endl;
}

int main() {
    ns::MyType obj;
    func(obj); // 这里会调用哪个func？
    return 0;
}
```

比如在以上例子中，在大多数情况下，如果两个函数都是有效的候选，并且没有一个比另一个更匹配（例如，它们都精确匹配调用），编译器将报错，指出调用有歧义。需要显式指定用哪个命名空间内的函数：
```cpp
int main() {
    ns::MyType obj;
    ns::func(obj); // 明确调用ns命名空间中的func
    ::func(obj);   // 明确调用全局命名空间中的func
    return 0;
}
```



# vk Instance

实例是应用程序与`Vulkan Library`之间沟通的桥梁；
`Vulkan API`使用`vkInstance`对象来存储所有每个应用程序的状态；

# Validation Layer

`Vulkan API`的设计核心是尽量最小化驱动程序的额外开销，所谓额外开销更多的是指渲染以外的运算，其中一个具体的表现就是默认条件下，`Vulkan API`的错误检查的支持非常有限；
即使遍历不正确的值或者将需要的参数传递为空指针，也不会有明确的处理逻辑，并且直接导致崩溃或者未定义的异常行为；

`Vulkan`推出了一个优化的系统，这个系统称之为`Validation layers`，`Validation layers`是可选组件，可以挂载到`Vulkan`函数中调用，以回调其他的操作；

功能有：
1. **错误检测**：验证层可以帮助开发者检测程序中的错误。例如，当你使用不正确的参数调用Vulkan函数时，验证层会生成一个错误消息，告诉你哪里出了问题。这可以帮助你更快地找到并修复错误。  
  
2. **性能警告**：验证层还可以检测潜在的性能问题。例如，当你使用低效的渲染路径时，验证层可能会生成一个警告消息，建议你使用更高效的方法。这可以帮助你优化程序的性能。  
  
3. **规范一致性**：验证层可以确保你的程序遵循Vulkan规范。这意味着你的程序在不同的硬件和驱动程序上更有可能正常工作。  
  
4. **调试支持**：验证层可以与调试器一起使用，以提供更详细的调试信息。例如，当你在调试器中设置一个断点时，验证层可以显示与当前Vulkan命令相关的所有参数和状态。这可以帮助你更容易地理解程序的运行情况。

要在Vulkan程序中启用验证层，你需要在创建`VkInstance`时指定所需的验证层；

验证层会造成性能上的损失，因此一般在发布版本中禁用Validation Layer；

# Window Surface

Vulkan是一个与平台特性无关联的API集合，它不能直接与窗口系统进行交互，为了将渲染结果呈现到屏幕，需要建立Vulkan与窗口系统之间的连接；
简单来说，`Window Surface`就是Vulkan与窗口系统之间的桥梁；

`VkSurfaceKHR`是Window Surface的一个抽象类型，使用该类型需要拓展`VK_KHR_Surface`的支持（该拓展已在`glfwGetRequiredInstanceExtensions`中获取）；

# Queue Family

队列族是一组具有相似特性的队列，这些队列可以执行各种类型的操作，如图形渲染、计算任务和数据传输。每个队列族都有一个或多个队列，这些队列可以**并行执行**任务。  
  
Vulkan设备（如GPU）上的不同队列族可能**具有不同的性能特征和功能**。例如，某些队列族可能专门用于图形渲染，而其他队列族可能更适合执行计算任务。在Vulkan应用程序中，开发人员需要根据任务的需求选择合适的队列族。

队列族**可能同时支持多种操作**，例如，一个队列族可能既支持图形渲染操作，也支持计算操作；

队列族的种类有：
1. **图形（Graphics）队列族**：这些队列族用于执行图形渲染操作，例如绘制三维场景。要检查一个队列族是否支持图形操作，可以检查其是否具有`VK_QUEUE_GRAPHICS_BIT`标志。  
  
2. **计算（Compute）队列族**：这些队列族专门用于执行计算任务，例如在GPU上运行计算着色器。要检查一个队列族是否支持计算操作，可以检查其是否具有`VK_QUEUE_COMPUTE_BIT`标志。  
  
3. **传输（Transfer）队列族**：这些队列族用于执行数据传输操作，例如从CPU内存复制数据到GPU内存。要检查一个队列族是否支持传输操作，可以检查其是否具有`VK_QUEUE_TRANSFER_BIT`标志。
  
4. **稀疏绑定（Sparse Binding）队列族**：这些队列族用于处理稀疏资源绑定操作，例如在使用稀疏纹理时。要检查一个队列族是否支持稀疏绑定操作，可以检查其是否具有`VK_QUEUE_SPARSE_BINDING_BIT`标志。  
  
5. **保护（Protected）队列族**：这些队列族用于执行受保护的操作，例如在使用受保护的内存时。要检查一个队列族是否支持保护操作，可以检查其是否具有`VK_QUEUE_PROTECTED_BIT`标志。

---
6. **呈现（Present）队列族**：呈现队列**不是一个独立的队列族类型**，而是与其他队列族（如图形队列族）**共享的功能**，作为一种特殊类型的队列，其功能是将渲染好的图像显示到屏幕上。呈现队列通常与图形队列（Graphics Queue）一起使用，以实现图形渲染和显示的完整流程；一般支持Graphic的队列族也支持Present；

# Swap Chain

交换链是一个用于在屏幕上呈现图像的关键概念。它是一系列图像（称为帧缓冲）的集合，这些图像在GPU和显示设备之间交换，以便在屏幕上显示。交换链的主要目的是在屏幕上显示渲染的图像，同时避免撕裂和卡顿现象。

# Image View

图像视图（Image View）是一个用于访问图像资源的关键概念。图像视图定义了如何将图像资源映射到管线阶段，以便在渲染过程中使用。它可以用于访问图像的特定部分，例如颜色、深度或模板。图像视图还可以用于指定图像的格式、类型和范围。

图像试图的作用有：
1. **访问图像资源**： 图像视图允许您在渲染过程中访问图像资源。例如，您可以将图像视图绑定到描述符集，以便在着色器中使用。

2. **指定图像格式和类型**： 图像视图允许您为图像资源指定格式和类型。这对于正确解释图像数据非常重要，因为它决定了如何将图像数据映射到管线阶段。

3. **访问图像的特定部分**： 图像视图允许您访问图像的特定部分，例如颜色、深度或模板。这对于实现多种渲染效果非常有用，例如阴影映射、环境光遮蔽等。

# Render Pass

渲染通道（Render Pass）是一个描述渲染操作的关键概念。它定义了一系列子通道（Subpasses）和附着（Attachments），这些子通道和附着用于在渲染过程中读取、写入和存储图像数据。渲染通道还描述了子通道之间的依赖关系，以确保正确的执行顺序和同步。

渲染通道的组成部分：
1. **子通道（Subpasses）**： 子通道是渲染通道中的一个阶段，用于执行特定的渲染操作，例如几何处理、光照计算等。子通道可以访问渲染通道中定义的附着，并根据需要读取和写入图像数据。

2. **附着（Attachments）**： 附着是渲染通道中的图像资源，用于存储渲染过程中生成的数据，例如颜色、深度和模板数据。附着可以在子通道之间共享，以便在渲染过程中重用图像数据。

3. **依赖关系（Dependencies）**： 依赖关系描述了子通道之间的执行顺序和同步要求。这确保了渲染操作按照正确的顺序执行，并避免了潜在的竞争条件和数据冲突。

## Subpass

subpass（子通道）是渲染管线（render pipeline）中的一个概念。它是渲染过程中的一个阶段，用于处理渲染操作的一部分。一个渲染管线可以包含多个子通道，这些子通道按顺序执行，以完成整个渲染过程。

子通道的主要作用是允许在不同的渲染阶段之间共享资源，例如图像和缓冲区。这可以提高渲染性能，因为它减少了内存带宽的需求和资源的重复使用。子通道之间的依赖关系通过依赖描述符（`dependency descriptors`）来定义，这些描述符指定了子通道之间的执行顺序和资源访问权限。

## Attachment

attachment（附件）是一个用于存储图像数据的内存对象。它通常用于渲染过程中的输入和输出，例如颜色缓冲区、深度缓冲区和模板缓冲区。在Vulkan渲染管线中，附件是通过`VkAttachmentDescription`结构体进行描述的，它包含了附件的格式、样本数、加载和存储操作等信息。

### Attachment Type

1. **颜色附件**（Color Attachment）：颜色附件用于存储渲染过程中生成的像素颜色值。在渲染管线的最后阶段，片段着色器输出的颜色值会被写入到颜色附件中。通常，颜色附件会关联到一个图像视图（image view），这个图像视图可以是一个纹理或者一个帧缓冲区。

2. **深度附件**（Depth Attachment）：深度附件用于存储渲染过程中生成的像素深度值。在渲染管线的早期阶段，深度测试会使用深度附件中的值来决定一个像素是否应该被绘制。深度附件通常与一个深度图像视图关联。

3. **模板附件**（Stencil Attachment）：模板附件用于存储渲染过程中生成的像素模板值。模板测试会使用模板附件中的值来决定一个像素是否应该被绘制。模板附件通常与一个模板图像视图关联。

4. **深度模板附件**（Depth Stencil Attachment）：深度模板附件是深度附件和模板附件的组合，它们共享同一个图像视图。这种类型的附件可以同时用于深度测试和模板测试。

这些附件类型通常在渲染过程中的子通道（subpass）中使用。子通道可以指定它们需要的附件类型，以及如何处理这些附件。

### Attachment Reference

attachment reference（附件引用）主要用于定义渲染过程中的输入和输出资源。它们在渲染过程中扮演着重要的角色，比如：

**颜色附件**：在渲染过程中，颜色附件用于存储渲染管线输出的颜色数据。通常，这些数据会被写入到一个图像中，以便在后续的渲染操作中使用。附件引用可以指定一个颜色附件，以便在渲染过程中使用。
```cpp
VkAttachmentReference colorAttachmentRef = {};
colorAttachmentRef.attachment = 0;
colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
```

**深度模板附件**：深度模板附件用于存储渲染管线输出的深度和模板数据。这些数据通常用于实现深度测试和模板测试等功能。附件引用可以指定一个深度模板附件，以便在渲染过程中使用。
```cpp
VkAttachmentReference depthStencilAttachmentRef = {};
depthStencilAttachmentRef.attachment = 1;
depthStencilAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
```

然后在`VkSubpassDescription`中被引用：
```cpp
VkSubpassDescription subpass = {};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
subpass.colorAttachmentCount = 1;
subpass.pColorAttachments = &colorAttachmentRef;
subpass.pDepthStencilAttachment = &depthStencilAttachmentRef;
```

## Dependency

依赖关系（dependency）是指在渲染过程中，不同操作之间的顺序和同步关系。Vulkan是一个低级别的图形和计算API，它允许开发者更精细地控制渲染管线和资源管理。为了实现这一点，Vulkan提供了一种描述操作之间依赖关系的方法，以确保正确的执行顺序和同步。

在Vulkan中，依赖关系主要通过`VkDependencyFlags`和`VkSubpassDependency`结构体来描述。`VkDependencyFlags`用于指定依赖关系的类型，如图形管线阶段之间的依赖关系、内存访问之间的依赖关系等。`VkSubpassDependency`结构体则用于描述渲染过程中子通道之间的依赖关系，包括源子通道、目标子通道、管线阶段、访问类型等信息。

# Stencil

在Vulkan中，模板（stencil）是一种图形渲染技术，用于控制哪些像素应该被绘制到屏幕上。模板缓冲区（stencil buffer）是一种特殊的缓冲区，用于存储每个像素的模板值。这些值可以用于执行各种操作，例如限制渲染到特定区域或实现阴影效果。

模板测试（stencil test）是在像素着色器（pixel shader）之前执行的一种测试，用于确定像素是否应该被绘制。模板测试根据模板缓冲区中的值和预先定义的模板函数（stencil function）来决定像素是否通过测试。如果像素通过了模板测试，它将继续进行后续的渲染操作，否则它将被丢弃。

模板操作（stencil operations）是在模板测试之后执行的一组操作，用于更新模板缓冲区中的值。这些操作可以根据像素是否通过深度测试（depth test）来选择不同的行为。例如，你可以在像素通过深度测试时递增模板值，而在像素未通过深度测试时保持模板值不变。

总之，在Vulkan中，模板（stencil）是一种用于控制像素渲染的技术，通过模板缓冲区、模板测试和模板操作来实现各种图形效果。

# Descriptor

`Descriptor`是一种描述渲染管线中资源绑定的机制。它可以用来指定着色器程序中使用的缓冲区、图像和采样器等资源。Descriptor可以看作是一种中介，**将着色器程序中的变量与实际的资源绑定**起来。在Vulkan中，Descriptor由`Descriptor Set`和`Descriptor Set Layout`两部分组成。`Descriptor Set Layout`定义了`Descriptor Set`中包含的Descriptor类型和数量，而`Descriptor Set`则实际绑定了资源。

## Descriptor Set

描述符集（`Descriptor Set`）是一组描述符绑定的集合。描述符绑定是指将着色器中的变量与实际的缓冲区、图像等资源进行绑定。descriptorSet中包含了多个描述符绑定，**每个描述符绑定对应一个着色器中的变量**。在渲染时，我们需要将descriptorSet绑定到渲染管线上，以便着色器可以访问到对应的资源。

## Descriptor Set Layout

`Descriptor Set Layout`是一种描述了在渲染过程中使用的`Uniform Buffer Objects`、`Texture Samplers`和`Input Attachments`的布局。它定义了这些资源在着色器中的绑定点和绑定顺序。`Descriptor Set Layout`可以在Pipeline创建时指定，以确保在渲染过程中正确地绑定资源。

## Descriptor Type

Vulkan中的descriptor type有以下几种：

1. Uniform Buffer：用于存储uniform数据的缓冲区。
2. Storage Buffer：用于存储shader读写数据的缓冲区。
3. Combined Image Sampler：用于存储图像和采样器的组合。
4. Sampled Image：用于存储采样器的图像。
5. Storage Image：用于存储shader读写数据的图像。
6. Uniform Texel Buffer：用于存储uniform数据的纹理缓冲区。
7. Storage Texel Buffer：用于存储shader读写数据的纹理缓冲区。


# Graphic Pipeline

`Graphic Pipeline`是一种用于渲染图形的流程。它由多个阶段组成，包括顶点输入、顶点着色器、图元装配、几何着色器、光栅化、片段着色器、颜色混合和输出合成。每个阶段都有自己的任务和输入输出，通过这些阶段的组合，可以实现高效的图形渲染。在Vulkan中，Graphic Pipeline是由多个可编程的`Shader Stage`组成的，这些Shader Stage可以使用`SPIR-V`语言编写。

## Shader Module

`Shader Module`是一个包含着色器代码的二进制文件。在Vulkan中，着色器代码必须被编译成`SPIR-V`格式的二进制代码，然后被加载到shader module中。Shader module可以被多个管线使用，因此它可以被看作是**一个可重用的着色器库**。 

## Dynamic State

`Dynamic State`允许应用程序在渲染管线的**执行期间更改某些状态，而无需重新创建管线**。这些状态包括视口、裁剪矩形、线宽、深度偏移和模板比较掩码等。使用Dynamic State可以提高应用程序的性能，因为它避免了在管线创建期间进行状态更改的开销。

## Vertex Input State

`Vertex input state`定义了如何从顶点缓冲区中读取顶点数据。具体来说，它包括顶点缓冲区的绑定描述和顶点属性描述。顶点缓冲区的绑定描述**定义了每个顶点数据的大小和偏移量**，而顶点属性描述定义了**每个顶点数据的格式和位置**。通过这些描述，Vulkan可以正确地解析顶点数据并将其传递给着色器程序。

### Vertex Input Binding Description

`Vertex Input Binding Description`是Vulkan中用于描述顶点输入数据的结构体。它包含了顶点缓冲区的绑定索引、顶点数据的步长和偏移量等信息。在Vulkan中，顶点数据需要通过这个结构体来告诉GPU如何解析顶点数据。

1. 绑定索引；
2. 占用字节数大小（`sizeof(Vertex3D)`）；
3. 传输速率；

### Vertex Input Attribute Description

`Vertex Input Attribute Description`是Vulkan中用于描述顶点输入数据的结构体。它包含了顶点数据的格式、绑定和偏移量等信息。在Vulkan中，顶点数据需要通过Vertex Input Attribute Description来告诉GPU如何解析顶点数据。这个结构体可以通过`VkVertexInputAttributeDescription`来定义，其中包含了location、binding、format和offset等成员变量。其中，location表示顶点着色器中的输入变量索引，binding表示顶点数据的绑定索引，format表示顶点数据的格式，offset表示顶点数据在缓冲区中的偏移量。

1. 绑定索引（与`Vertex Input Binding Description`中一致）；
2. 位置索引（比如pos为0，color为1，texcoord为2...）；
3. 格式（比如color为RGB32，texcoord为RG32）；
4. 偏移量；

## Input Assembly State

`Input Assembly State`指定如何将顶点数据组装成图元，包括是三角形还是举行、是否启用`primitive restart`；

### Primitive Restart

`primitive restart`是Vulkan图形API中的一个功能，它允许在绘制三角形条带时在顶点之间插入一个特殊的索引值，以指示该条带已经结束并且下一个条带已经开始。这个特殊的索引值可以通过调用`vkCmdSetPrimitiveRestartEnable`函数来设置。当启用`primitive restart`时，Vulkan将忽略插入的索引值，并将其视为一个新的三角形条带的开始。

## Viewport State

`Viewport State`定义了渲染管线中的**视口和裁剪矩形**。视口是一个矩形区域，它定义了渲染结果在屏幕上的位置和大小。裁剪矩形是一个矩形区域，它定义了哪些像素应该被渲染。`Viewport state`可以通过`VkViewport`和`VkRect2D`结构体来定义。在渲染管线中，`Viewport state`可以通过`VkPipelineViewportStateCreateInfo`结构体来指定。

### Viewport

在Vulkan中，渲染管线中的`Viewport`是指用于**定义渲染目标的可见区域**。它是一个矩形区域，用于指定渲染到屏幕上的图像的大小和位置。Viewport可以在管线中进行设置，以便在渲染过程中进行动态更改。Viewport的大小和位置可以通过设置视口变换来进行调整，这可以通过设置视口变换矩阵来实现。

### Scissor Rectangle

在Vulkan中，渲染管线中的`Scissor`是一个矩形区域，用于**指定渲染的区域**。在渲染过程中，只有在该矩形区域内的像素才会被渲染，从而提高了渲染效率。可以通过设置`VkPipelineViewportStateCreateInfo`结构体中的scissor成员变量来指定scissor矩形区域。


## Rasterization State

`Rasterization State`是Vulkan图形管线中的一个状态，它定义了如何将几何形状转换为像素。具体来说，它包括了如下几个方面：

- polygonMode：定义了如何填充多边形，可以是FILL（填充）、LINE（线框）或POINT（点）。
- cullMode：定义了哪些面需要被剔除，可以是NONE（不剔除）、FRONT（剔除正面）或BACK（剔除背面）。
- frontFace：定义了多边形正面的方向，可以是CLOCKWISE（顺时针）或COUNTER_CLOCKWISE（逆时针）。
- depthBiasEnable：是否启用深度偏移。
- depthBiasConstantFactor：深度偏移常量因子。
- depthBiasClamp：深度偏移最大值。
- depthBiasSlopeFactor：深度偏移斜率因子。

这些状态可以通过`VkPipelineRasterizationStateCreateInfo`结构体进行配置。

## Multisample State

`Multisample State`是Vulkan中的一个状态，它用于控制多重采样的行为。多重采样是一种技术，用于减少图形渲染中的锯齿状边缘和其他视觉伪影。在Vulkan中，您可以使用`VkPipelineMultisampleStateCreateInfo`结构体来配置多重采样状态。该结构体包含有关多重采样的各种设置，例如采样数量、采样掩码和采样模式。

## Depth Stencil State

Vulkan中的`Depth Stencil State`是一种用于控制深度测试和模板测试的状态对象。它包含了深度测试和模板测试的各种参数，例如深度比较函数、深度测试是否启用、模板测试是否启用等等。

## Color Blend State

Vulkan中的`Color Blend State`是一种用于控制颜色混合的状态。它允许您定义如何将多个颜色片段合并为单个输出颜色。在Vulkan中，Color Blend State由`VkPipelineColorBlendStateCreateInfo`结构体定义。该结构体包含了一些成员变量，如blendEnable、srcColorBlendFactor、dstColorBlendFactor等，用于控制颜色混合的行为。具体来说，`blendEnable`用于启用或禁用颜色混合，`srcColorBlendFactor`和`dstColorBlendFactor`用于指定源颜色和目标颜色的混合因子，`blendOp`用于指定混合操作的类型，`colorWriteMask`用于指定哪些颜色通道应该被写入到帧缓冲中。总之，Color Blend State是一个非常重要的状态，它可以帮助您实现各种颜色混合效果。

## Pipeline Layout

`Pipeline Layout`是一种描述着色器程序使用的资源的方式。它定义了着色器程序使用的uniform变量、存储缓冲区和图像等资源的布局。Pipeline Layout还定义了着色器程序使用的描述符集合，这些描述符集合包含了着色器程序需要的所有资源。Pipeline Layout是在创建管线时指定的，它确保了着色器程序使用的资源与管线的其他部分相匹配。

# Command Pool

`Command Pool`负责管理着命令缓冲区的分配和回收。它是一个轻量级的对象，可以在应用程序中创建多个Command Pool。每个Command Pool都**与一个特定的队列族相关联**，因此它只能用于该队列族中的命令缓冲区。当应用程序需要提交命令时，它可以从Command Pool中分配一个命令缓冲区，并将命令记录到该缓冲区中。当命令执行完毕后，应用程序可以将命令缓冲区返回给Command Pool以进行重用。这种方式可以提高性能，因为它**避免了频繁地创建和销毁命令缓冲区的开销**。

# Frame Buffer

`frame buffer`是一个用于存储渲染结果的内存区域。它包含了渲染所需的所有图像资源，如颜色、深度和模板缓冲区。在渲染过程中，图像资源会被写入到frame buffer中，最终呈现在屏幕上。frame buffer的大小和格式可以根据需要进行配置，以适应不同的渲染场景。在Vulkan中，frame buffer是由`render pass`和`swapchain image`创建的。`render pass`定义了渲染过程中的操作序列，而`swapchain image`则提供了用于显示渲染结果的图像资源。














# 内存类型

1. Device Local：能被GPU快速访问；
2. Host Visible：能够被CPU访问；
3. Host Coherent：保证CPU和GPU端内存的一致，不需要同步；
4. Host Cached：用于存放CPU缓存的内存，经常会被CPU读取；
5. Lazily Allocated：Vulkan根据需要分配；
6. 其他：比如Protected、Device Coherent AMD、Device Uncached AMD、RDMA Capable Nvidia；

内存类型的选择取决于应用程序的需求和设备的支持情况，应用程序需要根据实际情况选择合适的内存类型，以达到最佳的性能和效率。


### AMD的VMA库

VMA库提供了一种更容易理解的方式来管理内存，并进行内存分配；
1. `VMA_MEMORY_USAGE_GPU_ONLY`：被GPU读写，只能从CPU拷贝一次数据到GPU；适用于`Render Target`、`Depth Stencil`；
2. `VMA_MEMORY_USGAE_CPU_ONLY`：用于频繁地从CPU拷贝数据到GPU；适用于`Stage Buffer`；
3. `VMA_MEMORY_USGAE_CPU_TO_GPU`：用于偶尔地从CPU拷贝数据到GPU；适用于`Vertex Buffer`、`Uniform Buffer`、`Image`；
4. `VMA_MEMORY_USGAE_GPU_TO_CPU`：用于偶尔地从GPU拷贝数据到CPU；
5. `VMA_MEMORY_USGAE_CPU_COPY`：用于频繁地从GPU拷贝数据到CPU；
6. `.VMA_MEMORY_USGAE_GPU_LAZILY_ALLOCATED`：根据需要后续分配；

### Stage Buffer

分配一块类型为`Host Coherent`的内存作为`Stage Buffer`，用于CPU与GPU之间数据传输的桥梁；
能够减少数据传输的次数、减少消耗的时间、减少异步操作导致的问题；

一段使用Stage Buffer的传输Vertex Buffer数据的代码：
```cpp
VkDeviceSize verticesSize = sizeof(m_Vertices[0]) * m_Vertices.size();

//创建stageBufferMemory作为transfer的src
VkBuffer stagingBuffer;
VkDeviceMemory stagingBufferMemory;
createBuffer(verticesSize, 
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT,	//用途是作为transfer的src
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, //具有CPU可见的显存类型
	stagingBuffer, stagingBufferMemory);

//把Vertex数据传输到stageBufferMemory
void* vertexData;
vkMapMemory(m_LogicalDevice, stagingBufferMemory, 0, verticesSize, 0, &vertexData);
memcpy(vertexData, m_Vertices.data(), static_cast<size_t>(verticesSize));
vkUnmapMemory(m_LogicalDevice, stagingBufferMemory);

//创建device local的vertexBufferMemory作为transfer的dst
createBuffer(verticesSize, 
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT, //用途是作为transfer的dst、以及vertexBuffer
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,	//具有性能最佳的DeviceLocal显存类型
	m_VertexBuffer, m_VertexBufferMemory);

//传输数据，CPU to GPU
copyBuffer(stagingBuffer, m_VertexBuffer, verticesSize);

//清理stage buffer及其memory
vkDestroyBuffer(m_LogicalDevice, stagingBuffer, nullptr);
vkFreeMemory(m_LogicalDevice, stagingBufferMemory, nullptr);
```










# 区别

## Image与Image View

在Vulkan中，`Image`和`ImageView`是两个不同的概念。Image是一个内存中的图像对象，它包含了实际的像素数据以及描述这些数据的元数据。而ImageView是对Image的一个视图，它描述了如何访问Image中的像素数据。可以将ImageView看作是Image的一个窗口，它定义了Image中的哪些像素数据可以被读取或写入。

因此，Image和ImageView的区别在于它们所描述的对象不同。Image是一个内存中的图像对象，而ImageView是对Image的一个视图。在使用Vulkan时，我们通常需要同时创建Image和ImageView，以便能够对图像数据进行读取和写入。

## Depth Test与Stencil Test

在Vulkan中，深度测试和模板测试是两种不同的测试。深度测试用于确定像素是否应该被绘制，而模板测试用于确定像素是否应该被写入到帧缓冲区中。深度测试是通过比较像素的深度值来完成的，而模板测试是通过比较像素的模板值来完成的。深度测试和模板测试都可以用于实现各种效果，例如阴影、透明度和反射。在使用深度测试和模板测试时，需要注意它们的顺序，因为它们的顺序可能会影响最终的渲染结果。

## Semaphore与Fence

`Semaphore`和`Fence`都是Vulkan中用于同步操作的对象，但它们的作用略有不同。

Semaphore用于同步不同队列之间的操作，例如在图像呈现时，需要同步图像的呈现和渲染操作。Semaphore可以用于同步多个操作，但只能在两个队列之间同步。

Fence用于同步同一队列中的操作，例如在一个命令缓冲区中提交多个命令时，需要确保这些命令按顺序执行。Fence可以用于同步多个操作，但只能在同一队列中同步。

因此，Semaphore和Fence都是用于同步操作的对象，但Semaphore用于同步不同队列之间的操作，而Fence用于同步同一队列中的操作。

## Descriptor Set与Descriptor Set Layout

`descriptor set`和`descriptor set layout`是Vulkan中的两个概念。descriptor set是描述了一组资源绑定到管线上的方式，而descriptor set layout则是描述了这组资源的布局和绑定方式。

具体来说，descriptor set是一个包含了一组资源绑定信息的对象，包括了绑定的资源类型、数量、以及在管线上的绑定点等信息。而descriptor set layout则是描述了这组资源的布局和绑定方式，包括了每个资源的类型、数量、以及在descriptor set中的偏移量等信息。

在使用Vulkan时，我们需要先创建descriptor set layout，然后再创建descriptor set，并将资源绑定到descriptor set上。这样，我们就可以将descriptor set绑定到管线上，使得管线可以访问这些资源。
此处介绍一种工业界中常用的基于时间的滤波方法；
# 思路

1. 假设前一帧图像已经滤波完成，可以直接使用；
2. 使用运动向量（`Motion Vector`）找到某个点上一帧所在的位置；

![RTRT|350](https://pic-1315225359.cos.ap-shanghai.myqcloud.com/20230927152148.png)

3. 直接复用上一帧中该点的颜色（假设帧之间过渡平滑）；

# 找对应点

## Back Projection

Step1、找到当前帧像素点对应的场景中点的世界坐标；

方法一：预先将每个像素点对应的世界坐标存入`G-Buffer`，然后直接取即可；
方法二：进行逆视口变换、逆MVP变换等，还原出世界坐标；

Step2、找到上一帧点的世界坐标；

使用`Motion Vector`进行逆变换即可；

Step3、找到上一帧世界坐标对应的像素点；

使用MVP变换、视口变换等即可；

# 颜色混合

首先对当前帧进行空间域的滤波：

![RTRT|170](https://pic-1315225359.cos.ap-shanghai.myqcloud.com/20230927173001.png)

得到上一个点的颜色后，与当前点的颜色进行混合，一般取系数为 $\alpha=0.1-0.2$ ；

![RTRT|250](https://pic-1315225359.cos.ap-shanghai.myqcloud.com/20230927161610.png)

# 效果

![RTRT|600](https://pic-1315225359.cos.ap-shanghai.myqcloud.com/20230927164253.png)


# 缺陷

1. 某些情况下，上一帧的信息不能用；
	比如切换场景、光源变化、摄像机突变等；

2. 某些情况下，找不到上一帧的信息；
	比如摄像机往后移动，某些原本看不见的场景出现了，但它们上一帧并不在画面中，也就没有上一帧的颜色信息；

3. 某些情况下，上一帧的信息是错的；
	比如一面墙倒了，墙后面的场景突然出现了，此时获取的上一帧的颜色还是墙没有倒时的颜色；

如果无视这些问题，继续使用错误的信息，则会导致拖影问题（`Lagging`）；

![RTRT|600](https://pic-1315225359.cos.ap-shanghai.myqcloud.com/20230927164025.png)

4. 某些情况下，阴影也会出问题；
	比如一个场景中，摄像机和物体位置都没有发生变化，只有光源位置在变化，由于Motive Vector不存在，取的上一帧的信息其实是错的，就会产生阴影的滞后与拖影；

![RTRT|600](https://pic-1315225359.cos.ap-shanghai.myqcloud.com/20230927170547.png)

# 解决方法

## Clamping

假设当前帧的滤波结果为C，前一帧的滤波结果为P，它们之间的差异为D = C - P；
然后定义一个阈值T，如果D的绝对值大于T，就将D限制在(-T, T)的范围内；

这种方法可以防止滤波结果的突然变化，从而减少闪烁；
## Detection

使用某种检测方法判断上一帧信息的可信度，根据可信度动态调节混合系数 $\alpha$ ；
由于使用的当前帧的信息更多了，因此噪点也更明显了；
